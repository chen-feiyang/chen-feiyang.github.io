<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="generator" content="Hugo 0.58.1" />

  
  <meta name="description" content="Some description">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://chen-feiyang.github.io/apple-touch-icon.png">

  
  <link rel="icon" type="image/png" sizes="32x32" href="https://chen-feiyang.github.io/favicon-32x32.png">

  
  <link rel="icon" type="image/png" sizes="16x16" href="https://chen-feiyang.github.io/favicon-16x16.png">

  
  <link rel="manifest" href="https://chen-feiyang.github.io/site.webmanifest">

  
  <link rel="mask-icon" href="https://chen-feiyang.github.io/safari-pinned-tab.svg" color="#5bbad5">

  <meta name="msapplication-TileColor" content="#da532c">

  <meta name="theme-color" content="#ffffff">

  
  <link rel="stylesheet" href="https://chen-feiyang.github.io/css/bootstrap.min.css" />

  
  <title>Regular Expression HOWTO | Feiyang Chen&#39;s Blog</title>
  

  <style>
body {
  min-width: 300px;
}

.custom-navbar {
  margin-bottom: 1em;
  height: 60px;
}

.custom-navbar a {
  display: inline-block; 
  padding: 18px 0;
  margin-right: 1em; 
  font-weight: bold; 
}

.custom-navbar a:hover,
.custom-navbar a:focus {
  text-decoration: none; 
}

@media print {
  .custom-navbar {
    display: none;
  }
}

article {
  padding-bottom: 1em;
}

img {
  max-width: 100%;
}


body {
  background-color: #ffffff;
}



body {
  color: #212529;
}



a {
  color: #212529;
}



a:hover,
a:focus {
  color: #212529;
}



.custom-navbar {
  background-color: #212529;
}



.custom-navbar a {
  color: rgba(255, 255, 255, 0.75);
}



.custom-navbar a:hover,
.custom-navbar a:focus {
  color: rgba(255, 255, 255, 1);
}



.container {
  max-width: 800px;
}



pre {
  display: block;
  padding: 9.5px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
}

pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  white-space: pre-wrap;
  background-color: transparent;
  border: none;
  border-radius: 0;
}

code {
  padding: 2px 4px;
  color: inherit; 
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: .9em;
}



blockquote,
.blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 1em;
  border-left: 5px solid #6c757d;
}

</style>
</head>

<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>

<body>
  <nav class="custom-navbar">
  <div class="container">
    
    <a href="/">Posts</a>
    
    <a href="/tags/">Tags</a>
    
    <a href="/about/">About</a>
    
    <a href="/index.xml">RSS</a>
    
  </div>
</nav>
  
  <div class="container">
    <article>
      <h1>Regular Expression HOWTO</h1>


<!-- TOC -->

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#simple-patterns">Simple Patterns</a>

<ul>
<li><a href="#matching-characters">Matching Characters</a></li>
<li><a href="#repeating-things">Repeating Things</a></li>
</ul></li>
<li><a href="#using-regular-expressions">Using Regular Expressions</a>

<ul>
<li><a href="#compiling-regular-expressions">Compiling Regular Expressions</a></li>
<li><a href="#the-backslash-plague">The Backslash Plague</a></li>
<li><a href="#performing-matches">Performing Matches</a></li>
<li><a href="#module-level-functions">Module-Level Functions</a></li>
<li><a href="#compilation-flags">Compilation Flags</a></li>
</ul></li>
<li><a href="#more-pattern-power">More Pattern Power</a>

<ul>
<li><a href="#more-metacharacters">More Metacharacters</a></li>
<li><a href="#grouping">Grouping</a></li>
<li><a href="#non-capturing-and-named-groups">Non-capturing and Named Groups</a></li>
<li><a href="#lookahead-assertions">Lookahead Assertions</a></li>
</ul></li>
<li><a href="#modifying-strings">Modifying Strings</a>

<ul>
<li><a href="#splitting-strings">Splitting Strings</a></li>
<li><a href="#search-and-replace">Search and Replace</a></li>
</ul></li>
<li><a href="#common-problems">Common Problems</a>

<ul>
<li><a href="#use-string-methods">Use String Methods</a></li>
<li><a href="#match-versus-search">match() versus search()</a></li>
<li><a href="#greedy-versus-non-greedy">Greedy versus Non-Greedy</a></li>
<li><a href="#using-reverbose">Using re.VERBOSE</a></li>
</ul></li>
<li><a href="#feedback">Feedback</a></li>
</ul>

<!-- /TOC -->

<h1 id="introduction">Introduction</h1>

<p>Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the re module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways.</p>

<p>正则表达式(称为REs、regexes或regex模式)本质上是一种嵌入在Python中的小型、高度专门化的编程语言，可以通过re模块使用。使用这个小语言，您可以指定要匹配的可能字符串集的规则；这个集合可能包含英语句子、电子邮件地址、TeX命令或任何您喜欢的内容。然后可以问一些问题，比如“这个字符串与模式匹配吗?”，或“此字符串中的任何地方是否与模式匹配?”您还可以使用REs修改字符串或以各种方式将其拆分。</p>

<p>Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals.</p>

<p>正则表达式模式编译成一系列的字节码，然后由用C编写的匹配引擎执行高级使用，可能需要注意引擎将如何执行一个给定的RE，和怎么写RE以使生成字节码运行得更快。本文不讨论优化，因为它要求您很好地理解匹配引擎的内部机制。</p>

<p>The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.</p>

<p>正则表达式语言相对较小且受到限制，因此并不是所有可能的字符串处理任务都可以使用正则表达式来完成。也可以使用正则表达式完成一些任务，但是表达式非常复杂。在这些情况下，最好编写Python代码来进行处理；虽然Python代码比复杂的正则表达式要慢，但也可能更容易理解。</p>

<h1 id="simple-patterns">Simple Patterns</h1>

<p>We’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters.</p>

<p>我们将从学习最简单的正则表达式开始。由于正则表达式用于操作字符串，我们将从最常见的任务开始：匹配字符。</p>

<p>For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers.</p>

<p>要详细解释正则表达式（确定性和非确定性有限自动机）背后的计算机科学，可以参考几乎所有编写编译器的教科书。</p>

<h2 id="matching-characters">Matching Characters</h2>

<p>Most letters and characters will simply match themselves. For example, the regular expression <code>test</code> will match the string <code>test</code> exactly. (You can enable a case-insensitive mode that would let this RE match <code>Test</code> or <code>TEST</code> as well; more about this later.)</p>

<p>大多数字母和字符将简单地匹配它们自己。例如，正则表达式<code>test</code>将与字符串<code>test</code>完全匹配。（您可以启用不区分大小写的模式，让这个RE也匹配<code>Test</code>或<code>TEST</code>；稍后再详细介绍。）</p>

<p>There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do.</p>

<p>这条规则也有例外；有些字符是特殊的元字符，它们本身并不匹配。相反，它们表示应该匹配一些不寻常的东西，或者通过重复它们或改变它们的含义来影响RE的其他部分。本文主要讨论各种元字符及其作用。</p>

<p>Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO.</p>

<p>这是一个完整的元字符列表；它们的含义将在本文的其余部分中讨论。</p>

<pre><code>. ^ $ * + ? { } [ ] \ | ( )
</code></pre>

<p>The first metacharacters we’ll look at are <code>[</code> and <code>]</code>. They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a <code>'-'</code>. For example, <code>[abc]</code> will match any of the characters <code>a</code>, <code>b</code>, or <code>c</code>; this is the same as <code>[a-c]</code>, which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be <code>[a-z]</code>.</p>

<p>我们要看的第一个元字符是<code>[</code>和<code>]</code>。它们用于指定字符类，也就是您希望匹配的一组字符。字符可以单独列出，也可以通过给出两个字符并用<code>'-'</code>分隔它们来指定字符的范围。例如，<code>[abc]</code>将匹配任何字符<code>a</code>、<code>b</code>或<code>c</code>；与<code>[a-c]</code>一样，它使用一个范围来表示同一组字符。如果您只想匹配小写字母，您的RE将是<code>[a-z]</code>。</p>

<p>Metacharacters are not active inside classes. For example, <code>[akm$]</code> will match any of the characters <code>'a'</code>, <code>'k'</code>, <code>'m'</code>, or <code>'$'</code>; <code>'$'</code> is usually a metacharacter, but inside a character class it’s stripped of its special nature.</p>

<p>元字符在类中不活动。例如，<code>[akm$]</code>将匹配任何字符<code>'a'</code>、<code>'k'</code>、<code>'m'</code>或<code>'$'</code>；<code>'$'</code>通常是一个元字符，但在一个字符类中它被剥夺了它的特殊性质。</p>

<p>You can match the characters not listed within the class by complementing the set. This is indicated by including a <code>'^'</code> as the first character of the class. For example, <code>[^5]</code> will match any character except <code>'5'</code>. If the caret appears elsewhere in a character class, it does not have special meaning. For example: <code>[5^]</code> will match either a <code>'5'</code> or a <code>'^'</code>.</p>

<p>您可以通过补充集合来匹配类中没有列出的字符。这是通过在类的第一个字符中包含<code>'^'</code>来表示的。例如，<code>[^5]</code>将匹配除<code>'5'</code>之外的任何字符。如果插入符号出现在字符类的其他位置，则它没有特殊意义。例如:<code>[5^]</code>既可以与<code>'5'</code>匹配，也可以与<code>'^'</code>匹配。</p>

<p>Perhaps the most important metacharacter is the backslash, <code>\</code>. As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a <code>[</code> or <code>\</code>, you can precede them with a backslash to remove their special meaning: <code>\[</code> or <code>\\</code>.</p>

<p>也许最重要的元字符是反斜杠<code>\</code>。与Python字面的字符串一样，反斜杠后面可以跟各种字符，以表示各种特殊的序列。它还用于转义所有的元字符，以便您仍然可以在模式中匹配它们；例如，如果您需要匹配一个<code>[</code>或<code>\</code>，您可以在它们前面加上一个反斜杠来消除它们的特殊含义：<code>\[</code>或<code>\\</code>。</p>

<p>Some of the special sequences beginning with <code>'\'</code> represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace.</p>

<p>一些以<code>'\'</code>开头的特殊序列表示通常有用的预定义字符集，如数字集、字母集或除空白之外的任何东西的集。</p>

<p>Let’s take an example: <code>\w</code> matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class <code>[a-zA-Z0-9_]</code>. If the regex pattern is a string, <code>\w</code> will match all the characters marked as letters in the Unicode database provided by the <code>unicodedata</code> module. You can use the more restricted definition of <code>\w</code> in a string pattern by supplying the <code>re.ASCII</code> flag when compiling the regular expression.</p>

<p>让我们举个例子：<code>\w</code>匹配任何字母数字字符。如果regex模式是用字节表示的，这就相当于类<code>[a-zA-Z0-9_]</code>。如果regex模式是一个字符串，<code>\w</code>将匹配<code>unicodedata</code>模块提供的Unicode数据库中标记为字母的所有字符。通过在编译正则表达式时提供<code>re.ASCII</code>标志，在编译正则表达式时可以在字符串模式中使用更严格的<code>\w</code>定义。</p>

<p>The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of <code>Regular Expression Syntax</code> in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database.</p>

<p>下面的特殊序列列表并不完整。有关Unicode字符串模式的序列和扩展类定义的完整列表，请参阅标准库参考资料中的<code>Regular Expression Syntax</code>的最后一部分。通常，Unicode版本匹配Unicode数据库中相应类别中的任何字符。</p>

<ul>
<li><code>\d</code><br />
Matches any decimal digit; this is equivalent to the class <code>[0-9]</code>.</li>
<li><code>\D</code><br />
Matches any non-digit character; this is equivalent to the class <code>[^0-9]</code>.</li>
<li><code>\s</code><br />
Matches any whitespace character; this is equivalent to the class <code>[ \t\n\r\f\v]</code>.</li>
<li><code>\S</code><br />
Matches any non-whitespace character; this is equivalent to the class <code>[^ \t\n\r\f\v]</code>.</li>
<li><code>\w</code><br />
Matches any alphanumeric character; this is equivalent to the class <code>[a-zA-Z0-9_]</code>.</li>

<li><p><code>\W</code><br />
Matches any non-alphanumeric character; this is equivalent to the class <code>[^a-zA-Z0-9_]</code>.</p></li>

<li><p><code>\d</code><br />
匹配任何十进制数字；这相当于类<code>[0-9]</code>。</p></li>

<li><p><code>\D</code><br />
匹配任何非数字字符；这相当于类<code>[^0-9]</code>。</p></li>

<li><p><code>\s</code><br />
匹配任何空白字符；这相当于类<code>[ \t\n\r\f\v]</code>。</p></li>

<li><p><code>\S</code><br />
匹配任何非空白字符；这相当于类<code>[^ \t\n\r\f\v]</code>。</p></li>

<li><p><code>\w</code><br />
匹配任何字母数字字符；这相当于类<code>[a-zA-Z0-9_]</code>。</p></li>

<li><p><code>\W</code><br />
匹配任何非字母数字字符；这相当于类<code>[^a-zA-Z0-9_]</code>。</p></li>
</ul>

<p>These sequences can be included inside a character class. For example, <code>[\s,.]</code> is a character class that will match any whitespace character, or <code>','</code> or <code>'.'</code>.</p>

<p>这些序列可以包含在一个字符类中。例如，<code>[\s,.]</code>是一个字符类，将匹配任何空白字符，或<code>','</code>或<code>'.'</code>。</p>

<p>The final metacharacter in this section is <code>.</code>. It matches anything except a newline character, and there’s an alternate mode (<code>re.DOTALL</code>) where it will match even a newline. <code>.</code> is often used where you want to match “any character”.</p>

<p>本节的最后一个元字符是<code>.</code>。它可以匹配除换行字符之外的任何内容，并且有一个备用模式（<code>re.DOTALL</code>），它甚至可以匹配换行字符。<code>.</code>通常用在你想匹配“任何字符”的地方。</p>

<h2 id="repeating-things">Repeating Things</h2>

<p>Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times.</p>

<p>能够匹配不同的字符集是正则表达式所能做的第一件事，这在字符串上可用的方法中是不可能的。然而，如果这是regexes唯一的附加功能，那么它们就不会是很大的进步。另一种功能是，您可以指定必须重复一定次数的RE部分。</p>

<p>The first metacharacter for repeating things that we’ll look at is <code>*</code>. <code>*</code> doesn’t match the literal character <code>'*'</code>; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once.</p>

<p>第一个元字符用于重复我们将看到的东西是<code>*</code>。<code>*</code>与字面字符<code>'*'</code>不匹配；相反，它指定前一个字符可以匹配0次或更多次，而不是只匹配一次。</p>

<p>For example, <code>ca*t</code> will match <code>'ct'</code> (0 <code>'a'</code> characters), <code>'cat'</code> (1 <code>'a'</code>), <code>'caaat'</code> (3 <code>'a'</code> characters), and so forth.</p>

<p>例如，<code>ca*t</code>将匹配<code>'ct'</code>（0个<code>'a'</code>字符）、<code>'cat'</code>（1个<code>'a'</code>字符）、<code>'caaat'</code>（3个<code>'a'</code>字符）等等。</p>

<p>Repetitions such as <code>*</code> are <strong>greedy</strong>; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions.</p>

<p>像<code>*</code>这样的重复是<strong>贪婪的</strong>；当重复一个RE时，匹配的引擎会尽可能多地重复它。如果模式后面的部分不匹配，匹配引擎就会备份，然后用较少的重复进行重试。（即先尽可能多重复次数地匹配）</p>

<p>A step-by-step example will make this more obvious. Let’s consider the expression <code>a[bcd]*b</code>. This matches the letter <code>'a'</code>, zero or more letters from the class <code>[bcd]</code>, and finally ends with a <code>'b'</code>. Now imagine matching this RE against the string <code>'abcbd'</code>.</p>

<p>一个逐步的示例将使这一点更加明显。让我们来考虑一下<code>a[bcd]*b</code>这个表达式。它匹配字母<code>'a'</code>、类<code>[bcd]</code>中的零或多个字母，最后以一个<code>'b'</code>结尾。现在想象将这个RE与字符串<code>'abcbd'</code>相匹配。</p>

<table>
<thead>
<tr>
<th align="left">Step</th>
<th align="left">Matched</th>
<th align="left">Explanation</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left"><code>a</code></td>
<td align="left">The <code>a</code> in the RE matches.</td>
</tr>

<tr>
<td align="left">2</td>
<td align="left"><code>abcbd</code></td>
<td align="left">The engine matches <code>[bcd]*</code>, going as far as it can, which is to the end of the string.</td>
</tr>

<tr>
<td align="left">3</td>
<td align="left">Failure</td>
<td align="left">The engine tries to match <code>b</code>, but the current position is at the end of the string, so it fails.</td>
</tr>

<tr>
<td align="left">4</td>
<td align="left"><code>abcb</code></td>
<td align="left">Back up, so that <code>[bcd]*</code> matches one less character.</td>
</tr>

<tr>
<td align="left">5</td>
<td align="left">Failure</td>
<td align="left">Try <code>b</code> again, but the current position is at the last character, which is a <code>'d'</code>.</td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>abc</code></td>
<td align="left">Back up again, so that <code>[bcd]*</code> is only matching <code>bc</code>.</td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>abcb</code></td>
<td align="left">Try <code>b</code> again. This time the character at the current position is <code>'b'</code>, so it succeeds.</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">匹配</th>
<th align="left">解释</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">1</td>
<td align="left"><code>a</code></td>
<td align="left">匹配RE表达式中的<code>a</code>。</td>
</tr>

<tr>
<td align="left">2</td>
<td align="left"><code>abcbd</code></td>
<td align="left">引擎匹配<code>[bcd]*</code>，尽可能多地匹配，也就是匹配到字符<code>'abcbd'</code>的尽头。</td>
</tr>

<tr>
<td align="left">3</td>
<td align="left">Failure</td>
<td align="left">引擎试图匹配<code>b</code>，但当前位置是字符<code>'abcbd'</code>的尽头，所以失败了。</td>
</tr>

<tr>
<td align="left">4</td>
<td align="left"><code>abcb</code></td>
<td align="left">备份，以便<code>[bcd]*</code>匹配（目标字符的）少一个字符。</td>
</tr>

<tr>
<td align="left">5</td>
<td align="left">Failure</td>
<td align="left">再次尝试<code>b</code>，但当前位置是最后一个字符，也就是<code>'d'</code>。</td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>abc</code></td>
<td align="left">再次备份，以便<code>[bcd]*</code>只匹配<code>bc</code>。</td>
</tr>

<tr>
<td align="left">6</td>
<td align="left"><code>abcb</code></td>
<td align="left">再次尝试<code>b</code>。这次当前位置的字符是<code>'b'</code>，所以成功。</td>
</tr>
</tbody>
</table>

<p>The end of the RE has now been reached, and it has matched <code>'abcb'</code>. This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for <code>[bcd]*</code>, and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all.</p>

<p>现在到达了RE的末端，它匹配了<code>'abcb'</code>。这演示了匹配引擎如何在一开始就尽可能多地匹配，如果没有找到匹配，它将逐步备份，并一次又一次地重试其余部分。它将备份，直到它尝试了<code>[bcd]*</code>的零匹配，如果随后失败，引擎将得出结论，字符串根本不匹配RE。</p>

<p>Another repeating metacharacter is <code>+</code>, which matches one or more times. Pay careful attention to the difference between <code>*</code> and <code>+</code>; <code>*</code> matches zero or more times, so whatever’s being repeated may not be present at all, while <code>+</code> requires at least one occurrence. To use a similar example, <code>ca+t</code> will match <code>'cat'</code> (1 <code>'a'</code>), <code>'caaat'</code> (3 <code>'a'</code>s), but won’t match <code>'ct'</code>.</p>

<p>另一个重复元字符是<code>+</code>，它匹配一个或多个次。注意<code>*</code>和<code>+</code>的区别；<code>*</code>匹配0次或更多次，因此无论重复的是什么可能根本不存在，而<code>+</code>需要至少一次出现。举个类似的例子，<code>ca+t</code>会匹配<code>'cat'</code>（1个<code>'a'</code>），<code>'caaat'</code>（3个<code>'a'</code>），但不会匹配<code>'ct'</code>。</p>

<p>There are two more repeating qualifiers. The question mark character, <code>?</code>, matches either once or zero times; you can think of it as marking something as being optional. For example, <code>home-?brew</code> matches either <code>'homebrew'</code> or <code>'home-brew'</code>.</p>

<p>还有两个重复限定符。问号字符，<code>?</code>，匹配一次或零次；您可以将它看作是将某些东西标记为可选的。例如，<code>home-?brew</code>可以与<code>'homebrew'</code>或<code>'home-brew'</code>匹配。</p>

<p>The most complicated repeated qualifier is <code>{m,n}</code>, where <code>m</code> and <code>n</code> are decimal integers. This qualifier means there must be at least <code>m</code> repetitions, and at most <code>n</code>. For example, <code>a/{1,3}b</code> will match <code>'a/b'</code>, <code>'a//b'</code>, and <code>'a///b'</code>. It won’t match <code>'ab'</code>, which has no slashes, or <code>'a////b'</code>, which has four.</p>

<p>最复杂的重复限定词是<code>{m,n}</code>，其中<code>m</code>和<code>n</code>是十进制整数。这个限定词意味着至少有<code>m</code>个重复，最多有<code>n</code>个。例如，<code>a/{1,3}b</code>将匹配<code>'a/b'</code>，<code>'a//b'</code>，和<code>'a///b'</code>。它不匹配没有斜杠的<code>'ab'</code>，或者有四个斜杠的<code>'a////b'</code>。</p>

<p>You can omit either <code>m</code> or <code>n</code>; in that case, a reasonable value is assumed for the missing value. Omitting <code>m</code> is interpreted as a lower limit of 0, while omitting <code>n</code> results in an upper bound of infinity.</p>

<p>你可以省略<code>m</code>或<code>n</code>；在这种情况下，为丢失的值假定一个合理的值。省略<code>m</code>被解释为0的下限，而省略<code>n</code>则导致无穷大的上限。</p>

<p>Readers of a reductionist bent may notice that the three other qualifiers can all be expressed using this notation. <code>{0,}</code> is the same as <code>*</code>, <code>{1,}</code> is equivalent to <code>+</code>, and <code>{0,1}</code> is the same as <code>?</code>. It’s better to use <code>*</code>, <code>+</code>, or <code>?</code> when you can, simply because they’re shorter and easier to read.</p>

<p>简化论的读者可能会注意到，其他三个限定都可以用以下符号表示。<code>{0,}</code>与<code>*</code>一样，<code>{1,}</code>相当于<code>+</code>，<code>{0,1}</code>和<code>?</code>是一样。尽量使用<code>*</code>、<code>+</code>或<code>?</code>，只是因为它们更短，更容易阅读。</p>

<h1 id="using-regular-expressions">Using Regular Expressions</h1>

<p>Now that we’ve looked at some simple regular expressions, how do we actually use them in Python? The <code>re</code> module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them.</p>

<p>既然我们已经了解了一些简单的正则表达式，那么在Python中如何使用它们呢？<code>re</code>模块提供了到正则表达式引擎的接口，允许您将REs编译成对象，然后使用它们执行匹配。</p>

<h2 id="compiling-regular-expressions">Compiling Regular Expressions</h2>

<p>Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions.</p>

<p>正则表达式被编译成模式对象，模式对象具有用于搜索匹配的模式或执行字符串替换等各种操作的方法。</p>

<pre><code class="language-python">&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('ab*')
&gt;&gt;&gt; p
re.compile('ab*')
</code></pre>

<p><code>re.compile()</code> also accepts an optional <code>flags</code> argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do:</p>

<p><code>re.compile()</code>还接受可选的<code>flags</code>参数，用于启用各种特殊功能和语法变化。我们之后将涉及可用变量设定，但现在仅介绍一个单一的例子:</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('ab*', re.IGNORECASE)
</code></pre>

<p>The RE is passed to <code>re.compile()</code> as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the <code>re</code> module is simply a C extension module included with Python, just like the <code>socket</code> or <code>zlib</code> modules.</p>

<p>将RE作为字符串传递给<code>re.compile()</code>。RE被处理为字符串，因为正则表达式不是核心Python语言的一部分，并且没有创建特殊的语法来表示它们。(有些应用程序根本不需要RE，因此没有必要通过包含它们来扩展语言规范。)相反，<code>re</code>模块只是Python中包含的一个C扩展模块，就像<code>socket</code>或<code>zlib</code>模块一样。</p>

<p>Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section.</p>

<p>将RE放在字符串中可以使Python语言更简单，但是有一个缺点，这就是下一节的主题。</p>

<h2 id="the-backslash-plague">The Backslash Plague</h2>

<p>As stated earlier, regular expressions use the backslash character (<code>'\'</code>) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals.</p>

<p>如前所述，正则表达式使用反斜杠字符(<code>'\'</code>)来指示特殊形式，或者允许使用特殊字符而不调用它们的特殊含义。这与Python在字符串文本中出于相同目的使用相同字符的做法相冲突。</p>

<p>Let’s say you want to write a RE that matches the string <code>\section</code>, which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string <code>\\section</code>. The resulting string that must be passed to <code>re.compile()</code> must be <code>\\section</code>. However, to express this as a Python string literal, both backslashes must be escaped again.</p>

<p>假设您想要编写一个与字符串<code>\section</code>匹配的RE，这个字符串可能在LaTeX文件中找到。要确定在程序代码中要写什么，可以从需要匹配的字符串开始。接下来，必须通过在反斜杠和其他元字符前面加上反斜杠来转义它们，从而产生字符串<code>\\section</code>。必须传递给<code>re.compile()</code>的结果字符串必须是<code>\\section</code>。但是，要将其表示为Python字面上的字符串，必须再次转义两个反斜杠。</p>

<table>
<thead>
<tr>
<th align="left">Characters</th>
<th align="left">Stage</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>\section</code></td>
<td align="left">Text string to be matched</td>
</tr>

<tr>
<td align="left"><code>\\section</code></td>
<td align="left">Escaped backslash for <code>re.compile()</code></td>
</tr>

<tr>
<td align="left"><code>&quot;\\\\section&quot;</code></td>
<td align="left">Escaped backslashes for a string literal</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">阶段</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>\section</code></td>
<td align="left">要匹配的文本字符串</td>
</tr>

<tr>
<td align="left"><code>\\section</code></td>
<td align="left"><code>re.compile()</code>的转义反斜杠</td>
</tr>

<tr>
<td align="left"><code>&quot;\\\\section&quot;</code></td>
<td align="left">为字面上的字符串转义反斜杠</td>
</tr>
</tbody>
</table>

<p>In short, to match a literal backslash, one has to write <code>'\\\\'</code> as the RE string, because the regular expression must be <code>\\</code>, and each backslash must be expressed as <code>\\</code> inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand.</p>

<p>简而言之，要匹配字面的反斜杠，必须将<code>'\\\\'</code>作为RE字符串，因为正则表达式必须是<code>\\</code>，而且每个反斜杠必须在常规Python字面字符串中表示为<code>\\</code>。在反复使用反斜杠的RE中，这会导致大量重复的反斜杠，从而使生成的字符串难以理解。</p>

<p>The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with <code>'r'</code>, so <code>r&quot;\n&quot;</code> is a two-character string containing <code>'\'</code> and <code>'n'</code>, while <code>&quot;\n&quot;</code> is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation.</p>

<p>解决方案是对正则表达式使用Python的原始字符串表示法；反斜杠在以<code>'r'</code>为前缀的字面上的字符串中没有任何特殊的处理方法，因此<code>r&quot;\n&quot;</code>是一个包含<code>'\'</code>和<code>'n'</code>的双字符字符串，而<code>&quot;\n&quot;</code>是一个包含换行符的单字符字符串。正则表达式通常用Python代码编写，使用这种原始字符串表示法。</p>

<p>In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a <code>DeprecationWarning</code> and will eventually become a <code>SyntaxError</code>, which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used.</p>

<p>此外，特殊的转义序列在正则表达式中有效，但在Python字面上的字符串中无效，现在会导致<code>DeprecationWarning</code>，并最终成为<code>SyntaxError</code>，这意味着如果没有使用原始字符串表示法或转义反斜杠，这些序列将无效。</p>

<table>
<thead>
<tr>
<th align="left">Regular String</th>
<th align="left">Raw string</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>&quot;ab*&quot;</code></td>
<td align="left"><code>r&quot;ab*&quot;</code></td>
</tr>

<tr>
<td align="left"><code>&quot;\\\\section&quot;</code></td>
<td align="left"><code>r&quot;\\section&quot;</code></td>
</tr>

<tr>
<td align="left"><code>&quot;\\w+\\s+\\1&quot;</code></td>
<td align="left"><code>r&quot;\w+\s+\1&quot;</code></td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">正则符串</th>
<th align="left">原始字符串</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>&quot;ab*&quot;</code></td>
<td align="left"><code>r&quot;ab*&quot;</code></td>
</tr>

<tr>
<td align="left"><code>&quot;\\\\section&quot;</code></td>
<td align="left"><code>r&quot;\\section&quot;</code></td>
</tr>

<tr>
<td align="left"><code>&quot;\\w+\\s+\\1&quot;</code></td>
<td align="left"><code>r&quot;\w+\s+\1&quot;</code></td>
</tr>
</tbody>
</table>

<h2 id="performing-matches">Performing Matches</h2>

<p>Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the <code>re</code> docs for a complete listing.</p>

<p>有了表示编译后的正则表达式的对象后，如何处理它？模式对象有几个方法和属性。这里只讨论最重要的问题；查阅<code>re</code>文档以获得完整的列表。</p>

<table>
<thead>
<tr>
<th align="left">Method/Attribute</th>
<th align="left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>match()</code></td>
<td align="left">Determine if the RE matches at the beginning of the string.</td>
</tr>

<tr>
<td align="left"><code>search()</code></td>
<td align="left">Scan through a string, looking for any location where this RE matches.</td>
</tr>

<tr>
<td align="left"><code>findall()</code></td>
<td align="left">Find all substrings where the RE matches, and returns them as a list.</td>
</tr>

<tr>
<td align="left"><code>finditer()</code></td>
<td align="left">Find all substrings where the RE matches, and returns them as an <code>iterator</code>.</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">方法/属性</th>
<th align="left">目的</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>match()</code></td>
<td align="left">确定RE是否与字符串的开头匹配。</td>
</tr>

<tr>
<td align="left"><code>search()</code></td>
<td align="left">扫描一个字符串，寻找与此RE匹配的任何位置。</td>
</tr>

<tr>
<td align="left"><code>findall()</code></td>
<td align="left">找到所有与RE匹配的子字符串，并以列表的形式返回它们。</td>
</tr>

<tr>
<td align="left"><code>finditer()</code></td>
<td align="left">找到所有与RE匹配的子字符串，并以“迭代器”的形式返回它们。</td>
</tr>
</tbody>
</table>

<p><code>match()</code> and <code>search()</code> return <code>None</code> if no match can be found. If they’re successful, a <code>match object</code> instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more.</p>

<p>如果没有找到匹配，<code>match()</code>和<code>search()</code>返回<code>None</code>。如果成功，则返回一个<code>match object</code>实例，其中包含关于匹配的信息：它在哪里开始和结束，匹配的子字符串，等等。</p>

<p>You can learn about this by interactively experimenting with the <code>re</code> module. If you have <code>tkinter</code> available, you may also want to look at <code>Tools/demo/redemo.py</code>, a demonstration program included with the Python distribution. It allows you to enter REs and strings, and displays whether the RE matches or fails. <code>redemo.py</code> can be quite useful when trying to debug a complicated RE.</p>

<p>您可以通过交互试验<code>re</code>模块来了解这一点。如果你有<code>tkinter</code>可用，你也可以看看<code>Tools/demo/redemo.py</code>。一个包含在Python发行版中的演示程序。它允许您输入RE和字符串，并显示RE是否匹配或失败。<code>redemo.py</code>在调试复杂的RE时非常有用。</p>

<p>This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the <code>re</code> module, and compile a RE:</p>

<p>本指南使用标准的Python解释器进行示例。首先，运行Python解释器，导入<code>re</code>模块，编译一个RE：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; import re
&gt;&gt;&gt; p = re.compile('[a-z]+')
&gt;&gt;&gt; p
re.compile('[a-z]+')
</code></pre>

<p>Now, you can try matching various strings against the RE <code>[a-z]+</code>. An empty string shouldn’t match at all, since <code>+</code> means ‘one or more repetitions’. <code>match()</code> should return <code>None</code> in this case, which will cause the interpreter to print no output. You can explicitly print the result of <code>match()</code> to make this clear.</p>

<p>现在，您可以尝试根据RE的<code>[a-z]+</code>匹配各种字符串。空字符串不应该能匹配，因为<code>+</code>意味着“一个或多个重复”。在本例中，<code>match()</code>应该返回<code>None</code>，这将导致解释器不打印输出。您可以显式地打印<code>match()</code>的结果来明确这一点。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p.match(&quot;&quot;)
&gt;&gt;&gt; print(p.match(&quot;&quot;))
None
</code></pre>

<p>Now, let’s try it on a string that it should match, such as <code>tempo</code>. In this case, <code>match()</code> will return a <code>match object</code>, so you should store the result in a variable for later use.</p>

<p>现在，让我们在一个应该能匹配的字符串上试试，比如<code>tempo</code>。在本例中，<code>match()</code>将返回一个<code>match object</code>，您应该将结果存储在一个变量中，供以后使用。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m = p.match('tempo')
&gt;&gt;&gt; m
&lt;re.Match object; span=(0, 5), match='tempo'&gt;
</code></pre>

<p>Now you can query the <code>match object</code> for information about the matching string. Match object instances also have several methods and attributes; the most important ones are:</p>

<p>现在您可以查询<code>match object</code>以获得关于匹配字符串的信息。匹配对象实例也有几个方法和属性；最重要的是:</p>

<table>
<thead>
<tr>
<th align="left">Method/Attribute</th>
<th align="left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>group()</code></td>
<td align="left">Return the string matched by the RE</td>
</tr>

<tr>
<td align="left"><code>start()</code></td>
<td align="left">Return the starting position of the match</td>
</tr>

<tr>
<td align="left"><code>end()</code></td>
<td align="left">Return the ending position of the match</td>
</tr>

<tr>
<td align="left"><code>span()</code></td>
<td align="left">Return a tuple containing the (start, end) positions of the match</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">方法/属性</th>
<th align="left">目的</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>group()</code></td>
<td align="left">返回由RE匹配的字符串</td>
</tr>

<tr>
<td align="left"><code>start()</code></td>
<td align="left">返回匹配的起始位置</td>
</tr>

<tr>
<td align="left"><code>end()</code></td>
<td align="left">返回匹配的结束位置</td>
</tr>

<tr>
<td align="left"><code>span()</code></td>
<td align="left">返回包含匹配的(开始、结束)位置的元组</td>
</tr>
</tbody>
</table>

<p>Trying these methods will soon clarify their meaning:</p>

<p>尝试这些方法很快就能弄清它们的含义：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m.group()
'tempo'
&gt;&gt;&gt; m.start(), m.end()
(0, 5)
&gt;&gt;&gt; m.span()
(0, 5)
</code></pre>

<p><code>group()</code> returns the substring that was matched by the RE. <code>start()</code> and <code>end()</code> return the starting and ending index of the match. <code>span()</code> returns both start and end indexes in a single tuple. Since the <code>match()</code> method only checks if the RE matches at the start of a string, <code>start()</code> will always be zero. However, the <code>search()</code> method of patterns scans through the string, so the match may not start at zero in that case.</p>

<p><code>group()</code>返回由RE匹配的子字符串。<code>start()</code>和<code>end()</code>返回匹配的开始和结束索引。<code>span()</code>返回一个元组中的开始和结束索引。因为<code>match()</code>方法只检查字符串开头的RE是否匹配，所以<code>start()</code>总是0。但是，模式的<code>search()</code>方法会扫描字符串，所以在这种情况下，匹配可能不会从0开始。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(p.match('::: message'))
None
&gt;&gt;&gt; m = p.search('::: message'); print(m)
&lt;re.Match object; span=(4, 11), match='message'&gt;
&gt;&gt;&gt; m.group()
'message'
&gt;&gt;&gt; m.span()
(4, 11)
</code></pre>

<p>In actual programs, the most common style is to store the <code>match object</code> in a variable, and then check if it was <code>None</code>. This usually looks like:</p>

<p>在实际的程序中，最常见的样式是将<code>match object</code>存储在一个变量中，然后检查它是否是<code>None</code>。通常是这样：</p>

<pre><code class="language-python">p = re.compile( ... )
m = p.match( 'string goes here' )
if m:
    print('Match found: ', m.group())
else:
    print('No match')
</code></pre>

<p>Two pattern methods return all of the matches for a pattern. <code>findall()</code> returns a list of matching strings:</p>

<p>两个模式方法返回一个模式的所有匹配项。<code>findall()</code>返回匹配字符串列表：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']
</code></pre>

<p>注意以下也成立：</p>

<pre><code class="language-python">&gt;&gt;&gt; p = re.compile('\d+')
&gt;&gt;&gt; p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')
['12', '11', '10']
&gt;&gt;&gt;
</code></pre>

<p>注：</p>

<ul>
<li>紧上示例中使用<code>r&quot;some string&quot;</code>来省略<code>some string</code>中的一些<code>\</code>符号，但<code>some string</code>中哪些<code>\</code>符号是能被省略的？
正则匹配有以下几个概念：1.我们需要匹配的字符称为<strong>目标字符</strong>；2.需要匹配得到字符，为这一目的而制定的匹配目标字符的规则称为<strong>正则表达式</strong>RE。<strong>正则表达式</strong>内部包含<strong>正则元字符</strong>（Metacharacters，如<code>\d</code>等代表所有数字）和<strong>字面字符</strong>（literal strings，如我们在正则表达式中需要匹配<code>韩国</code>这个固定字符或至少<code>韩国</code>这个固定字符是需要匹配得到内容的一部分），正则元字符和字面字符可能含有反斜杠<code>\</code>，如果正则表达式中前没有<code>r</code>表示这是原始字面字符串，其中字面字符中的反斜杠需要转义，即在反斜杠<code>\</code>前再加反斜杠成<code>\\</code>。而加了<code>r</code>前缀，则不需要对正则表达式中的字面字符中的<code>\</code>加反斜杠为<code>\\</code>。具体到紧上的示例，由于正则表达式中的反斜杠<code>\</code>出现在正则元字符，并不一定得使用<code>r</code>前缀。所以紧下这段认为此示例非得加<code>r</code>前缀是错误的，我也已给出了示例证明不必加<code>r</code>前缀。</li>
</ul>

<p>The <code>r</code> prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a <code>DeprecationWarning</code> and will eventually become a <code>SyntaxError</code>. See The <code>Backslash Plague</code>.</p>

<p>在本例中需要使用<code>r</code>前缀，使字面成为原始字面字符串，因为Python无法识别的正常“熟”的字面字符串中的转义序列（与正则表达式相反），现在会导致<code>DeprecationWarning</code>，并最终成为<code>SyntaxError</code>。看看<code>Backslash Plague</code>（反斜杠瘟疫）。（注：本段话是错误的，这里可不加<code>r</code>前缀。）</p>

<p><code>findall()</code> has to create the entire list before it can be returned as the result. The <code>finditer()</code> method returns a sequence of <code>match object</code> instances as an <code>iterator</code>:</p>

<p><code>findall()</code>必须创建整个列表才能返回结果。'<code>finditer()</code>方法以<code>iterator</code>的形式返回一个<code>match object</code>实例序列:</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; iterator = p.finditer('12 drummers drumming, 11 ... 10 ...')
&gt;&gt;&gt; iterator  
&lt;callable_iterator object at 0x...&gt;
&gt;&gt;&gt; for match in iterator:
...     print(match.span())
...
(0, 2)
(22, 24)
(29, 31)
</code></pre>

<h2 id="module-level-functions">Module-Level Functions</h2>

<p>You don’t have to create a pattern object and call its methods; the <code>re</code> module also provides top-level functions called <code>match()</code>, <code>search()</code>, <code>findall()</code>, <code>sub()</code>, and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either <code>None</code> or a <code>match object</code> instance.</p>

<p>您不必创建一个模式对象并调用它的方法；<code>re</code>模块还提供了名为<code>match()</code>、<code>search()</code>、<code>findall()</code>、<code>sub()</code>等顶级函数。这些函数使用与对应模式方法相同的参数，并将RE字符串添加为第一个参数，但仍然返回<code>None</code>或<code>match object</code>实例。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.match(r'From\s+', 'Fromage amk'))
None
&gt;&gt;&gt; re.match(r'From\s+', 'From amk Thu May 14 19:12:10 1998')  
&lt;re.Match object; span=(0, 5), match='From '&gt;
</code></pre>

<p>Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again.</p>

<p>实际上，这些函数只是为您创建一个模式对象并在其上调用适当的方法。它们还将编译后的对象存储在缓存中，因此使用相同RE的未来调用不需要一次又一次地解析模式。</p>

<p>Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache.</p>

<p>应该使用这些模块级函数，还是应该自己获取模式并调用它的方法？如果在循环中访问regex，预编译它将节省一些函数调用。在循环之外，由于内部缓存，没有太大的区别。</p>

<h2 id="compilation-flags">Compilation Flags</h2>

<p>Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the <code>re</code> module under two names, a long name such as <code>IGNORECASE</code> and a short, one-letter form such as <code>I</code>. (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of <code>re.VERBOSE</code> is <code>re.X</code>, for example.) Multiple flags can be specified by bitwise OR-ing them; <code>re.I | re.M</code> sets both the <code>I</code> and <code>M</code> flags, for example.</p>

<p>编译标志允许您修改正则表达式工作方式的某些方面。标志在<code>re</code>模块中有两个名称，一个长名称（如<code>IGNORECASE</code>）和一个短的单字母形式（如<code>I</code>）。（如果您熟悉Perl的模式修饰符，那么一个字母的表单使用相同的字母；例如，<code>re.VERBOSE</code>的缩写形式是<code>re.X</code>。）。通过位与可指定多个标志；例如，<code>re.I | re.M</code>将同时设定<code>I</code>和<code>M</code>标志。</p>

<p>Here’s a table of the available flags, followed by a more detailed explanation of each one.</p>

<p>下面是可用标志的表，后面是每个标志的详细说明。</p>

<table>
<thead>
<tr>
<th align="left">Flag</th>
<th align="left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>ASCII</code>, <code>A</code></td>
<td align="left">Makes several escapes like <code>\w</code>, <code>\b</code>, <code>\s</code> and <code>\d</code> match only on ASCII characters with the respective property.</td>
</tr>

<tr>
<td align="left"><code>DOTALL</code>, <code>S</code></td>
<td align="left">Make <code>.</code> match any character, including newlines.</td>
</tr>

<tr>
<td align="left"><code>IGNORECASE</code>, <code>I</code></td>
<td align="left">Do case-insensitive matches.</td>
</tr>

<tr>
<td align="left"><code>LOCALE</code>, <code>L</code></td>
<td align="left">Do a locale-aware match.</td>
</tr>

<tr>
<td align="left"><code>MULTILINE</code>, <code>M</code></td>
<td align="left">Multi-line matching, affecting <code>^</code> and <code>$</code>.</td>
</tr>

<tr>
<td align="left"><code>VERBOSE</code>, <code>X</code> (for ‘extended’)</td>
<td align="left">Enable verbose REs, which can be organized more cleanly and understandably.</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">标志</th>
<th align="left">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>ASCII</code>, <code>A</code></td>
<td align="left">对<code>\w</code>、<code>\b</code>、<code>\s</code>和<code>\d</code>等多个转义，仅在ASCII字符上与各自的属性匹配。</td>
</tr>

<tr>
<td align="left"><code>DOTALL</code>, <code>S</code></td>
<td align="left">使<code>.</code>匹配任何字符，包括换行符。</td>
</tr>

<tr>
<td align="left"><code>IGNORECASE</code>, <code>I</code></td>
<td align="left">不区分大小写的匹配。</td>
</tr>

<tr>
<td align="left"><code>LOCALE</code>, <code>L</code></td>
<td align="left">执行位置感知的匹配。</td>
</tr>

<tr>
<td align="left"><code>MULTILINE</code>, <code>M</code></td>
<td align="left">多行匹配，影响<code>^</code>和<code>$</code>。</td>
</tr>

<tr>
<td align="left"><code>VERBOSE</code>, <code>X</code> (for ‘extended’)</td>
<td align="left">启用详细的RE，可以更清晰、更容易理解地组织它们。</td>
</tr>
</tbody>
</table>

<ul>
<li><strong>I</strong><br />
<strong>IGNORECASE</strong><br />
Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, <code>[A-Z]</code> will match lowercase letters, too. Full Unicode matching also works unless the <code>ASCII</code> flag is used to disable non-ASCII matches. When the <code>Unicode</code> patterns <code>[a-z]</code> or <code>[A-Z]</code> are used in combination with the <code>IGNORECASE</code> flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). Spam will match <code>'Spam'</code>, <code>'spam'</code>, <code>'spAM'</code>, or <code>'ſpam'</code> (the latter is matched only in <code>Unicode</code> mode). This lowercasing doesn’t take the current locale into account; it will if you also set the <code>LOCALE</code> flag.</li>
<li><strong>L</strong><br />
<strong>LOCALE</strong><br />
Make <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> and case-insensitive matching dependent on the current locale instead of the <code>Unicode</code> database.<br />
Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write <code>\w+</code> to match words, but <code>\w</code> only matches the character class <code>[A-Za-z]</code> in bytes patterns; it won’t match bytes corresponding to <code>é</code> or <code>ç</code>. If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to <code>é</code> should also be considered a letter. Setting the <code>LOCALE</code> flag when compiling a regular expression will cause the resulting compiled object to use these C functions for <code>\w</code>; this is slower, but also enables <code>\w+</code> to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages.</li>
<li><strong>M</strong><br />
<strong>MULTILINE</strong><br />
(<code>^</code> and <code>$</code> haven’t been explained yet; they’ll be introduced in section <code>More Metacharacters</code>.)<br />
Usually <code>^</code> matches only at the beginning of the string, and <code>$</code> matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, <code>^</code> matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the <code>$</code> metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline).</li>
<li><strong>S</strong><br />
<strong>DOTALL</strong><br />
Makes the <code>'.'</code> special character match any character at all, including a newline; without this flag, <code>'.'</code> will match anything except a newline.</li>
<li><strong>A</strong><br />
<strong>ASCII</strong><br />
Make <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\s</code> and <code>\S</code> perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns.</li>

<li><p><strong>X</strong><br />
<strong>VERBOSE</strong><br />
This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a <code>'#'</code> that’s neither in a character class or preceded by an unescaped backslash.</p></li>

<li><p><strong>I</strong><br />
<strong>IGNORECASE</strong><br />
执行不区分大小写的匹配；字符类和字面上的字符串将通过忽略大小写来匹配字母。例如，<code>[A-Z]</code>也将匹配小写字母。除非使用<code>ASCII</code>标志禁用非ASCII匹配，否则所有Unicode匹配也可以工作。当<code>Unicode</code>模式<code>[a-z]</code>或<code>[A-Z]</code>被用于结合<code>IGNORECASE</code>标志，他们会匹配52个ASCII字母和4额外的非ASCII字母：İ（U+0130，拉丁大写字母I上加一点），ı（U+0131，拉丁小字母i不含点），ſ（U+017F，拉丁小字母s变长）和K（U+212A，Kelvin记号）。<code>Spam</code>将匹配<code>'Spam'</code>、<code>'spam'</code>、<code>'spAM'</code>或<code>'ſpam'</code>（后者只在<code>Unicode</code>模式匹配）。这个小写字母没有考虑当前本地语言环境；如果你也设置了<code>LOCALE</code>标志，它才会匹配。</p></li>

<li><p><strong>L</strong><br />
<strong>LOCALE</strong><br />
Make <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> and case-insensitive matching dependent on the current locale instead of the <code>Unicode</code> database.<br />
Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write <code>\w+</code> to match words, but <code>\w</code> only matches the character class <code>[A-Za-z]</code> in bytes patterns; it won’t match bytes corresponding to <code>é</code> or <code>ç</code>. If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to <code>é</code> should also be considered a letter. Setting the <code>LOCALE</code> flag when compiling a regular expression will cause the resulting compiled object to use these C functions for <code>\w</code>; this is slower, but also enables <code>\w+</code> to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages.
使<code>\w</code>、<code>\W</code>、<code>\b</code>、<code>\B</code>和大小写不敏感的匹配依赖于当前本地语言环境，而不是Unicode数据库。<br />
本地（locale）是C库的一个特性，旨在帮助编写考虑到语言差异的程序。例如，如果您正在处理已编码的法语文本，您希望能够编写<code>\w+</code>来匹配单词，但是<code>\w+</code>只匹配字符类<code>[A-Za-z]</code>的字节模式；它不会匹配与<code>é</code>或<code>ç</code>对应的字节。如果您的系统配置正确，并且选择了法语语言环境，那么某些C函数将告诉程序，与<code>é</code>对应的字节也应该被视为字母。在编译正则表达式时设置<code>LOCALE</code>标志将导致编译后的对象对<code>\w</code>使用这些C函数；这样会慢一些，但也能让<code>\w</code>匹配你所期望的法语单词。Python3不鼓励使用这个标志，因为语言环境机制非常不可靠，它一次只处理一个“区域性”，而且只适用于8位的语言环境。Python3中的Unicode (str)模式默认已经启用了<code>Unicode</code>匹配，并且它能够处理不同的地区/语言。</p></li>

<li><p><strong>M</strong><br />
<strong>MULTILINE</strong><br />
（<code>^</code>和<code>$</code>还没有解释;它们将在“更多的元字符”一节中介绍。）<br />
通常，<code>^</code>只匹配字符串的开头部分，<code>$</code>只匹配字符串的结尾部分和紧接在换行(如果有的话)之前的字符串结尾部分。当指定此标志时，<code>^</code>匹配字符串的开头和字符串中每行的开头，紧接在每行换行之后。类似地，<code>$</code>元字符在字符串的末尾和每行的末尾(紧接在每行换行之前)匹配。</p></li>

<li><p><strong>S</strong><br />
<strong>DOTALL</strong><br />
使<code>'.'</code>特殊字符匹配任何字符，包括换行；没有这个标志，<code>'.'</code>将匹配除换行以外的任何内容。</p></li>

<li><p><strong>A</strong><br />
<strong>ASCII</strong><br />
使<code>\w</code>、<code>\W</code>、<code>\b</code>、<code>\B</code>、<code>\s</code>和<code>\S</code>只执行ASCII匹配，而不执行完整的Unicode匹配。这只对Unicode模式有意义，而对字节模式则忽略不计。</p></li>

<li><p><strong>X</strong><br />
<strong>VERBOSE</strong><br />
This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a <code>'#'</code> that’s neither in a character class or preceded by an unescaped backslash.
此标志允许您编写更具可读性的正则表达式，从而使您在格式化正则表达式的方式上具有更大的灵活性。当指定了此标志时，将忽略RE字符串中的空白，除非空白位于字符类中或前面有未转义的反斜杠；这可以让你更清楚地组织和缩进的RE。此标志还允许您将注释放在一个将被引擎忽略的RE中；注释由<code>'#'</code>标记，它既不属于字符类，也不以未转义的反斜杠开头。</p></li>
</ul>

<p>For example, here’s a RE that uses <code>re.VERBOSE</code>; see how much easier it is to read?</p>

<p>例如，这里有一个RE使用了<code>re.VERBOSE</code>；看出来了吗?</p>

<pre><code class="language-python">charref = re.compile(r&quot;&quot;&quot;
 &amp;[#]                # Start of a numeric entity reference
 (
     0[0-7]+         # Octal form
   | [0-9]+          # Decimal form
   | x[0-9a-fA-F]+   # Hexadecimal form
 )
 ;                   # Trailing semicolon
&quot;&quot;&quot;, re.VERBOSE)
</code></pre>

<p>Without the verbose setting, the RE would look like this:</p>

<p>没有冗长（verbose）的设置，RE应该是这样的:</p>

<pre><code class="language-python">charref = re.compile(&quot;&amp;#(0[0-7]+&quot;
                     &quot;|[0-9]+&quot;
                     &quot;|x[0-9a-fA-F]+);&quot;)
</code></pre>

<p>In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using <code>re.VERBOSE</code>.</p>

<p>在上面的例子中，Python的字符串字面量的自动连接被用来将RE分解成更小的块，但是它仍然比使用<code>re.VERBOSE</code>的版本更难理解。</p>

<h1 id="more-pattern-power">More Pattern Power</h1>

<p>So far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched.</p>

<p>到目前为止，我们只介绍了正则表达式的一部分特性。在本节中，我们将介绍一些新的元字符，以及如何使用组来检索匹配的文本部分。</p>

<h2 id="more-metacharacters">More Metacharacters</h2>

<p>There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section.</p>

<p>有一些元字符我们还没有涉及。本节将介绍其中的大多数。</p>

<p>Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, <code>\b</code> is an assertion that the current position is located at a word boundary; the position isn’t changed by the <code>\b</code> at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times.</p>

<p>剩下要讨论的一些元字符是零宽度断言。它们不会使引擎通过字符前进；相反，它们根本不消耗任何字符，只是成功或失败。例如，<code>\b</code>是当前位置位于单词边界的断言；位置一点也没有被<code>\b</code>改变。这意味着不应该重复零宽度的断言，因为如果它们在给定位置匹配一次，显然可以匹配无限次。</p>

<ul>
<li><code>|</code><br />
Alternation, or the “or” operator. If <code>A</code> and <code>B</code> are regular expressions, <code>A|B</code> will match any string that matches either <code>A</code> or <code>B</code>. <code>|</code> has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. <code>Crow|Servo</code> will match either <code>'Crow'</code> or <code>'Servo'</code>, not <code>'Cro'</code>, a <code>'w'</code> or an <code>'S'</code>, and <code>'ervo'</code>.<br />
To match a literal <code>'|'</code>, use <code>\|</code>, or enclose it inside a character class, as in <code>[|]</code>.</li>

<li><p><code>^</code><br />
Matches at the beginning of lines. Unless the <code>MULTILINE</code> flag has been set, this will only match at the beginning of the string. In <code>MULTILINE</code> mode, this also matches immediately after each newline within the string.<br />
For example, if you wish to match the word <code>From</code> only at the beginning of a line, the RE to use is <code>^From</code>.</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.search('^From', 'From Here to Eternity'))  
&lt;re.Match object; span=(0, 4), match='From'&gt;
&gt;&gt;&gt; print(re.search('^From', 'Reciting From Memory'))
None
</code></pre>

<p>To match a literal <code>'^'</code>, use <code>\^</code>.</p></li>

<li><p><code>$</code><br />
Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character.</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.search('}$', '{block}'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
&gt;&gt;&gt; print(re.search('}$', '{block} '))
None
&gt;&gt;&gt; print(re.search('}$', '{block}\n'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
</code></pre>

<p>To match a literal <code>'$'</code>, use <code>\$</code> or enclose it inside a character class, as in <code>[$]</code>.</p></li>

<li><p><code>\A</code><br />
Matches only at the start of the string. When not in <code>MULTILINE</code> mode, <code>\A</code> and <code>^</code> are effectively the same. In <code>MULTILINE</code> mode, they’re different: <code>\A</code> still matches only at the beginning of the string, but <code>^</code> may match at any location inside the string that follows a newline character.</p></li>

<li><p><code>\Z</code><br />
Matches only at the end of the string.</p></li>

<li><p><code>\b</code><br />
Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character.<br />
The following example matches <code>class</code> only when it’s a complete word; it won’t match when it’s contained inside another word.</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
&lt;re.Match object; span=(3, 8), match='class'&gt;
&gt;&gt;&gt; print(p.search('the declassified algorithm'))
None
&gt;&gt;&gt; print(p.search('one subclass is'))
None
</code></pre>

<p>There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, <code>\b</code> is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the <code>\b</code> to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the <code>'r'</code> in front of the RE string.</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
None
&gt;&gt;&gt; print(p.search('\b' + 'class' + '\b'))
&lt;re.Match object; span=(0, 7), match='\x08class\x08'&gt;
</code></pre>

<p>Second, inside a character class, where there’s no use for this assertion, <code>\b</code> represents the backspace character, for compatibility with Python’s string literals.</p></li>

<li><p><code>\B</code><br />
Another zero-width assertion, this is the opposite of <code>\b</code>, only matching when the current position is not at a word boundary.</p></li>

<li><p><code>|</code><br />
“或”操作符。如果<code>A</code>和<code>B</code>是正则表达式，<code>A|B</code>将匹配任何与<code>A</code>或<code>B</code>匹配的字符串。<code>|</code>的优先级很低，以便在交替使用多字符字符串时能够合理地工作。<code>Crow|Servo</code>将匹配<code>'Crow'</code>或<code>'Servo'</code>，不匹配<code>'Cro'</code>，一个<code>'w'</code>或者一个<code>'S'</code>,和<code>'ervo'</code>。<br />
若要匹配字面的<code>'|'</code>，请使用<code>\|</code>，或将其放在字符类中，如<code>[|]</code>。</p></li>

<li><p><code>^</code><br />
在行的开头匹配。除非已经设置了<code>MULTILINE</code>标志，否则它只会匹配字符串的开头。在<code>MULTILINE</code>模式下，它也会在字符串中的每个换行之后立即匹配。<br />
例如，如果您希望仅匹配行首的单词From，那么应该使用<code>^From</code>。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.search('^From', 'From Here to Eternity'))  
&lt;re.Match object; span=(0, 4), match='From'&gt;
&gt;&gt;&gt; print(re.search('^From', 'Reciting From Memory'))
None
</code></pre>

<p>要匹配字面的<code>^</code>，使用<code>\^</code>。</p></li>

<li><p><code>$</code><br />
匹配位于行的末尾的位置，该行定义为字符串的末尾，或后跟换行字符的任何位置。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.search('}$', '{block}'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
&gt;&gt;&gt; print(re.search('}$', '{block} '))
None
&gt;&gt;&gt; print(re.search('}$', '{block}\n'))  
&lt;re.Match object; span=(6, 7), match='}'&gt;
</code></pre>

<p>To match a literal <code>'$'</code>, use <code>\$</code> or enclose it inside a character class, as in <code>[$]</code>.
若要匹配字面的<code>'$'</code>，请使用<code>\$</code>或将其放在字符类中，如<code>[$]</code>。</p></li>

<li><p><code>\A</code><br />
仅在字符串的开头匹配。当不在<code>MULTILINE</code>模式时，<code>\A</code>和<code>^</code>实际上是相同的。在<code>MULTILINE</code>模式下，它们是不同的：<code>\A</code>仍然只匹配字符串的开头，但是<code>^</code>可以匹配换行符后面的字符串中的任何位置。</p></li>

<li><p><code>\Z</code><br />
仅在字符串末尾匹配。</p></li>

<li><p><code>\b</code><br />
词边界。这是一个零宽度的断言，仅匹配单词的开头或结尾。一个单词被定义为一个字母数字字符序列，因此单词的结尾由空格或非字母数字字符表示。<br />
下面的示例仅当<code>class</code>是一个完整的单词时才匹配它；当它包含在另一个单词中时，它将不匹配。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
&lt;re.Match object; span=(3, 8), match='class'&gt;
&gt;&gt;&gt; print(p.search('the declassified algorithm'))
None
&gt;&gt;&gt; print(p.search('one subclass is'))
None
</code></pre>

<p>在使用这个特殊的序列时，您应该记住两个细微之处。首先，这是Python的字面的字符串和正则表达式序列之间最严重的冲突。在Python的字面的字符串中，<code>\b</code>是退格字符，ASCII值8。如果您没有使用原始字符串（即字符串前加<code>r</code>，如紧上示例所示。），那么Python会将<code>\b</code>转换为退格，您的RE将不会像您期望的那样匹配。下面的示例看起来与前面的RE相同，但是省略了RE字符串前面的<code>r</code>（在紧下这个示例中，正则表达式中的<code>\b</code>被视为退格符。<code>'no class at all'</code>并不会被<code>'\bclass\b'</code>匹配，因为<code>'no class at all'</code>虽然含有退格但不含退格符。而<code>'\b' + 'class' + '\b'</code>也就是<code>'\bclass\b'</code>含有退格符。）。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('\bclass\b')
&gt;&gt;&gt; print(p.search('no class at all'))
None
&gt;&gt;&gt; print(p.search('\b' + 'class' + '\b'))
&lt;re.Match object; span=(0, 7), match='\x08class\x08'&gt;
</code></pre>

<p>其次，在一个字符类中，这里没有使用这个断言，<code>\b</code>表示退格字符，以便与Python的字面字符串兼容。</p></li>

<li><p><code>\B</code><br />
另一个零宽度断言，它与<code>\b</code>相反，只在当前位置不在单词边界时匹配。</p></li>
</ul>

<h2 id="grouping">Grouping</h2>

<p>Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a <code>':'</code>, like this:</p>

<p>通常，您需要获得比是否重新匹配更多的信息。正则表达式通常用于通过将字符串重新划分为几个匹配不同兴趣组件的子组来分析字符串。例如，一个RFC-822头行被分为一个头名和一个值，中间用<code>':'</code>分隔，就像这样：</p>

<pre><code>From: author@example.com
User-Agent: Thunderbird 1.5.0.9 (X11/20061227)
MIME-Version: 1.0
To: editor@example.com
</code></pre>

<p>This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value.</p>

<p>这可以通过编写一个与整个标题行匹配的正则表达式来处理，其中一个组与标题名匹配，另一个组与标题的值匹配。</p>

<p>Groups are marked by the <code>'('</code>, <code>')'</code> metacharacters. <code>'('</code> and <code>')'</code> have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a repeating qualifier, such as <code>*</code>, <code>+</code>, <code>?</code>, or <code>{m,n}</code>. For example, <code>(ab)*</code> will match zero or more repetitions of <code>ab</code>.</p>

<p>组由<code>'('</code>，<code>')'</code>元字符标记。<code>'('</code>和<code>')'</code>的意思与数学表达式中的意思大致相同；它们将其中包含的表达式组合在一起，您可以使用重复限定词重复组的内容，比如<code>*</code>、<code>+</code>、<code>?</code>或<code>{m,n}</code>。例如，<code>(ab)*</code>将匹配零次或多次重复的<code>ab</code>。（也就是将<code>'('</code>和<code>')'</code>包含的内容视为一个整体，这与元字符是<code>[</code>和<code>]</code>不同，如紧下示例所示。）</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('(ab)*')
&gt;&gt;&gt; print(p.match('ababababab').span())
(0, 10)
</code></pre>

<p>Groups indicated with <code>'('</code>, <code>')'</code> also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to <code>group()</code>, <code>start()</code>, <code>end()</code>, and <code>span()</code>. Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so <code>match object</code> methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match.</p>

<p>用<code>'('</code>，<code>')'</code>表示的组还捕获它们匹配的文本的起始和结束索引；这可以通过向<code>group()</code>、<code>start()</code>、<code>end()</code>和<code>span()</code>传递参数来检索。组的编号从0开始。0组始终存在；它是整个RE，所以<code>match object</code>方法都有group 0作为默认参数。稍后，我们将看到如何表示不捕获匹配文本范围的组。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('(a)b')
&gt;&gt;&gt; m = p.match('ab')
&gt;&gt;&gt; m.group()
'ab'
&gt;&gt;&gt; m.group(0)
'ab'
</code></pre>

<p>Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right.</p>

<p>子组从左到右编号，从1开始向上编号。组可以嵌套；要确定数字（比如紧下，只有group 0到group 2，为什么知道？因为正则内只有两层<code>'('</code>和<code>')'</code>，因此2曾子组共三层），只需计算左到右的左括号字符。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('(a(b)c)d')
&gt;&gt;&gt; m = p.match('abcd')
&gt;&gt;&gt; m.group(0)
'abcd'
&gt;&gt;&gt; m.group(1)
'abc'
&gt;&gt;&gt; m.group(2)
'b'
</code></pre>

<p><code>group()</code> can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups.</p>

<p><code>group()</code>可以一次传递多个组号，在这种情况下，它将返回一个元组，其中包含这些组的相应值。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m.group(2,1,2)
('b', 'abc', 'b')
</code></pre>

<p>The <code>group()</code> method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are.</p>

<p><code>group()</code>方法返回一个元组，其中包含所有子组的字符串，从1到任意数目。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m.groups()
('abc', 'b')
</code></pre>

<p>Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, <code>\1</code> will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE.</p>

<p>模式中的反向引用允许您指定必须在字符串的当前位置找到先前捕获组的内容。例如，如果可以在当前位置找到组1的确切内容，则<code>\1</code>将成功，否则将失败。请记住，Python的字面字符串也使用反斜杠和数字，以允许在字符串中包含任意字符，所以在RE中合并反向引用时，一定要使用原始字符串（即字符串前加r，如之前示例所示。）。</p>

<p>For example, the following RE detects doubled words in a string.</p>

<p>例如，下面的RE将检测字符串中重复出现的单词。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\b(\w+)\s+\1\b')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</code></pre>

<p>Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions.</p>

<p>像这样的反向引用在搜索字符串时通常不是很有用——很少有文本格式以这种方式重复数据——但是您很快就会发现它们在执行字符串替换时非常有用。</p>

<h2 id="non-capturing-and-named-groups">Non-capturing and Named Groups</h2>

<p>这节挺复杂，没看懂！！！</p>

<p>Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first.</p>

<p>复杂的REs可以使用许多组，既可以捕获感兴趣的子字符串，也可以对RE本身进行分组和构造。在复杂的REs中，很难跟踪组号。有两个特性可以帮助解决这个问题。它们都使用了正则表达式扩展的通用语法，所以我们先来看一下。</p>

<p>Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with <code>\</code> without making Perl’s regular expressions confusingly different from standard REs. If they chose <code>&amp;</code> as a new metacharacter, for example, old expressions would be assuming that <code>&amp;</code> was a regular character and wouldn’t have escaped it by writing <code>\&amp;</code> or <code>[&amp;]</code>.</p>

<p>Perl 5以其对标准正则表达式的强大增强而闻名。对于这些新特性Perl开发人员不能选择以<code>\</code>开头但没有不同于标准RE的令人困惑的Perl正则表达式的新的单击键元字符或特殊序列。如果他们选择了<code>&amp;</code>作为一种新的元字符,例如,旧的表达式将假设<code>&amp;</code>是一个正则字符，并通过写<code>\&amp;</code>或<code>[&amp;]</code>以使<code>&amp;</code>不转义。</p>

<p>The solution chosen by the Perl developers was to use <code>(?...)</code> as the extension syntax. <code>?</code> immediately after a parenthesis was a syntax error because the <code>?</code> would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the <code>?</code> indicate what extension is being used, so <code>(?=foo)</code> is one thing (a positive lookahead assertion) and <code>(?:foo)</code> is something else (a non-capturing group containing the subexpression <code>foo</code>).</p>

<p>Perl开发人员选择的解决方案是使用<code>(?...)</code>作为扩展语法。<code>?</code>后面紧跟着一个括号是一个语法错误，因为<code>?</code>没有什么可以重复的，所以这并没有带来任何兼容性问题。<code>?</code>紧后字符表示使用的是哪个扩展名，因此<code>(?=foo)</code>是一个东西（一个积极的前向断言，下一节将介绍前向断言），<code>(?:foo)</code>是另一个东西（一个包含子表达式<code>foo</code>的非捕获组）。</p>

<p>Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a <code>P</code>, you know that it’s an extension that’s specific to Python.</p>

<p>Python支持几个Perl扩展，并将扩展语法添加到Perl扩展语法中。如果问号后面的第一个字符是<code>P</code>，那么您就知道它是Python特有的扩展。</p>

<p>Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs.</p>

<p>现在我们已经了解了一般的扩展语法，我们可以返回到在复杂REs中简化使用组的特性。</p>

<p>Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: <code>(?:...)</code>, where you can replace the <code>...</code> with any other regular expression.</p>

<p>有时，您可能希望使用组来表示正则表达式的一部分，但对检索组的内容不感兴趣。您可以通过使用非捕获组<code>(?:...)</code>来明确这一事实，其中可以将<code>...</code>替换为任何其它正则表达式。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m = re.match(&quot;([abc])+&quot;, &quot;abc&quot;)
&gt;&gt;&gt; m.groups()
('c',)
&gt;&gt;&gt; m = re.match(&quot;(?:[abc])+&quot;, &quot;abc&quot;)
&gt;&gt;&gt; m.groups()
()
</code></pre>

<p>注：</p>

<ul>
<li><code>&quot;([abc])+&quot;</code>解析，<code>&quot;()&quot;</code>代表组，<code>&quot;+&quot;</code>代表重复至少一次，组内的元素是<code>&quot;[abc]&quot;</code>，也即<code>&quot;[abc]&quot;</code>、<code>&quot;[abc]&quot;</code>或<code>&quot;[abc]&quot;</code>中任意一个字符，那么为什么返回<code>'c'</code>？</li>
<li><code>&quot;(?:[abc])+&quot;</code>代表与&quot;([abc])+&quot;对应的非捕获组？</li>
</ul>

<p>Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as <code>*</code>, and nest it within other groups (capturing or non-capturing). <code>(?:...)</code> is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other.</p>

<p>除了您无法检索组匹配的内容之外，非捕获组的行为与捕获组完全相同；您可以将任何内容放入其中，使用重复元字符（例如<code>*</code>）重复它，并将其嵌入其他组（捕捉组或非捕捉组）。<code>(?:...)</code>在修改现有模式时特别有用，因为您可以添加新的组，而不必更改所有其他组的编号方式。需要指出的是，捕获组和非捕获组的搜索性能没有区别；这两种形式都不如另一种形式快。</p>

<p>A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name.</p>

<p>一个更重要的特性是命名组：可以通过名称引用组，而不是通过数字引用组。</p>

<p>The syntax for a named group is one of the Python-specific extensions: <code>(?P&lt;name&gt;...)</code>. <code>name</code> is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The <code>match object</code> methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways:</p>

<p>指定组的语法是特定于python的扩展之一：<code>(?P&lt;name&gt;...)</code>。显然，<code>name</code>是组的名称。命名组的行为与捕获组完全相同，并且将名称与组关联起来。处理捕获组的<code>match object</code>方法都接受通过数字引用组的整数或包含所需组名称的字符串。命名组仍然是给定的数字，所以您可以通过两种方式检索关于一个组的信息：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\b\w+\b)')
&gt;&gt;&gt; m = p.search( '(((( Lots of punctuation )))' )
&gt;&gt;&gt; m.group('word')
'Lots'
&gt;&gt;&gt; m.group(1)
'Lots'
</code></pre>

<p>Additionally, you can retrieve named groups as a dictionary with <code>groupdict()</code>:</p>

<p>此外，作为一个字典，您可通过<code>groupdict()</code>检索命名组：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; m = re.match(r'(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)', 'Jane Doe')
&gt;&gt;&gt; m.groupdict()
{'first': 'Jane', 'last': 'Doe'}
</code></pre>

<p>Named groups are handy because they let you use easily-remembered names, instead of having to remember numbers. Here’s an example RE from the <code>imaplib</code> module:</p>

<p>命名组很方便，因为它让您使用容易记住的名称，而不必记住数字。以下是来自<code>imaplib</code>模块的一个例子:</p>

<pre><code class="language-python">InternalDate = re.compile(r'INTERNALDATE &quot;'
        r'(?P&lt;day&gt;[ 123][0-9])-(?P&lt;mon&gt;[A-Z][a-z][a-z])-'
        r'(?P&lt;year&gt;[0-9][0-9][0-9][0-9])'
        r' (?P&lt;hour&gt;[0-9][0-9]):(?P&lt;min&gt;[0-9][0-9]):(?P&lt;sec&gt;[0-9][0-9])'
        r' (?P&lt;zonen&gt;[-+])(?P&lt;zoneh&gt;[0-9][0-9])(?P&lt;zonem&gt;[0-9][0-9])'
        r'&quot;')
</code></pre>

<p>It’s obviously much easier to retrieve <code>m.group('zonem')</code>, instead of having to remember to retrieve group 9.</p>

<p>显然，检索<code>m.group('zonem')</code>要容易得多，而不必记住检索第9组。</p>

<p>The syntax for backreferences in an expression such as <code>(...)\1</code> refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: <code>(?P=name)</code> indicates that the contents of the group called <code>name</code> should again be matched at the current point. The regular expression for finding doubled words, <code>\b(\w+)\s+\1\b</code> can also be written as <code>\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</code>:</p>

<p><code>(...)\1</code>等表达式中的反向引用语法指的是组的数量。很自然，有一种变体使用组名而不是数字。这是另一个Python扩展:<code>(?P=name)</code>表示名为<code>name</code>的组的内容应该在当前点再次匹配。查找双引号的正则表达式<code>\b(\w+)\s+\1\b</code>也可以写成<code>\b(?P&lt;word&gt;\w+)\s+(?P=word)\b</code>：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\b(?P&lt;word&gt;\w+)\s+(?P=word)\b')
&gt;&gt;&gt; p.search('Paris in the the spring').group()
'the the'
</code></pre>

<h2 id="lookahead-assertions">Lookahead Assertions</h2>

<p>Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this:</p>

<p>另一个零宽度断言是前向断言。前向断言有正反两种形式，如下所示：</p>

<ul>
<li><code>(?=...)</code><br />
Positive lookahead assertion. This succeeds if the contained regular expression, represented here by <code>...</code>, successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started.</li>

<li><p><code>(?!...)</code><br />
Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string.</p></li>

<li><p><code>(?=...)</code><br />
正的超前断言。如果包含的正则表达式在这里由<code>...</code>代表，则在当前位置成功匹配，否则失败。但是，一旦尝试了所包含的表达式，匹配引擎就不再前进了；模式的其余部分在断言开始的地方进行尝试。</p></li>

<li><p><code>(?!...)</code><br />
反的前向断言。这是正的前向断言的反面；如果包含的表达式在字符串的当前位置不匹配，则会成功。</p></li>
</ul>

<p>To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a <code>.</code>. For example, in <code>news.rc</code>, <code>news</code> is the base name, and <code>rc</code> is the filename’s extension.</p>

<p>为了使其更具体，我们来看一个使用前向的情况。考虑一个简单的模式来匹配一个文件名，并将其拆分为一个基本名和一个扩展名，中间用<code>.</code>分隔。例如，在<code>news.rc</code>中，<code>news</code>是基本名，<code>rc</code>是文件名的扩展名。</p>

<p>The pattern to match this is quite simple:</p>

<p>匹配的模式很简单：</p>

<p><code>.*[.].*$</code></p>

<p>Notice that the <code>.</code> needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing <code>$</code>; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches <code>foo.bar</code> and <code>autoexec.bat</code> and <code>sendmail.cf</code> and <code>printers.conf</code>.</p>

<p>注意<code>.</code>需要特别处理，因为它是一个元字符，所以它在一个字符类中（即用<code>[</code>和<code>]</code>包裹成<code>[.]</code>，当然也可加<code>\</code>来转义写成<code>\.</code>），只匹配特定的字符。还要注意结尾的<code>$</code>；这是为了确保所有其余的字符串必须包含在扩展中。这个正则表达式匹配<code>foo.bar</code>、<code>autoexec.bat</code>、<code>sendmail.cf</code>和<code>printers.conf</code>。</p>

<p>Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not bat? Some incorrect attempts:</p>

<p>现在，考虑一下把问题复杂化一点；如果要匹配扩展名不是bat的文件名，该怎么办？一些错误的尝试：</p>

<p><code>.*[.][^b].*$</code></p>

<p>The first attempt above tries to exclude <code>bat</code> by requiring that the first character of the extension is not a <code>b</code>. This is wrong, because the pattern also doesn’t match <code>foo.bar</code>.</p>

<p>上面的第一次尝试通过要求扩展的第一个字符不是<code>b</code>来排除<code>bat</code>。这是错误的，因为模式也不匹配<code>foo.bar</code>。</p>

<p><code>.*[.]([^b]..|.[^a].|..[^t])$</code></p>

<p>The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t <code>b</code>; the second character isn’t <code>a</code>; or the third character isn’t <code>t</code>. This accepts <code>foo.bar</code> and rejects <code>autoexec.bat</code>, but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as <code>sendmail.cf</code>. We’ll complicate the pattern again in an effort to fix it.</p>

<p>当您试图通过要求匹配下列情况之一来修补第一个解决方案时，表达式变得更混乱：扩展的第一个字符不是<code>b</code>；第二个字母不是<code>a</code>；或者第三个字符不是<code>t</code>。这接受<code>foo.bar</code>并拒绝<code>autoexec.bat</code>，但它需要三个字母的扩展名，不接受两个字母扩展名的文件名，如<code>sendmail.cf</code>。为了修复它，我们将再次使模式复杂化。</p>

<p><code>.*[.]([^b].?.?|.[^a]?.?|..?[^t]?)$</code></p>

<p>In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as <code>sendmail.cf</code>.</p>

<p>在第三次尝试中，第二和第三个字母都是可选的，以便允许匹配短于三个字符的扩展名，比如<code>sendmail.cf</code>。</p>

<p>The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both <code>bat</code> and <code>exe</code> as extensions, the pattern would get even more complicated and confusing.</p>

<p>这个模式现在变得非常复杂，很难阅读和理解。更糟糕的是，如果问题发生了变化，并且您想要同时排除<code>bat</code>和<code>exe</code>扩展，那么模式将变得更加复杂和混乱。</p>

<p>A negative lookahead cuts through all this confusion:</p>

<p>一个反的前向断言打破所有的混乱：</p>

<p><code>.*[.](?!bat$)[^.]*$</code></p>

<p>The negative lookahead means: if the expression <code>bat</code> doesn’t match at this point, try the rest of the pattern; if <code>bat$</code> does match, the whole pattern will fail. The trailing <code>$</code> is required to ensure that something like <code>sample.batch</code>, where the extension only starts with <code>bat</code>, will be allowed. The <code>[^.]*</code> makes sure that the pattern works when there are multiple dots in the filename.</p>

<p>反的前向断言的意义：如果表达式<code>bat</code>此时不匹配，则尝试其余的模式；如果<code>bat$</code>确实匹配，那么整个模式将失败。后面的<code>$</code>是用来确保类似<code>sample.batch</code>的内容，这里扩展名仅以<code>bat</code>开始，将被允许。<code>[^.]*</code>确保当文件名中有多个点时模式有效。</p>

<p>Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either <code>bat</code> or <code>exe</code>:</p>

<p>排除另一个文件名扩展现在很容易；只需在断言中添加它作为替代。以下模式排除以<code>bat</code>或<code>exe</code>结尾的文件名：</p>

<p><code>.*[.](?!bat$|exe$)[^.]*$</code></p>

<h1 id="modifying-strings">Modifying Strings</h1>

<p>Up to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods:</p>

<p>到目前为止，我们只是对一个静态字符串执行搜索。正则表达式还通常用于以各种方式修改字符串，使用以下模式方法：</p>

<table>
<thead>
<tr>
<th align="left">Method/Attribute</th>
<th align="left">Purpose</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>split()</code></td>
<td align="left">Split the string into a list, splitting it wherever the RE matches</td>
</tr>

<tr>
<td align="left"><code>sub()</code></td>
<td align="left">Find all substrings where the RE matches, and replace them with a different string</td>
</tr>

<tr>
<td align="left"><code>subn()</code></td>
<td align="left">Does the same thing as <code>sub()</code>, but returns the new string and the number of replacements</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">方法/属性</th>
<th align="left">目的</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>split()</code></td>
<td align="left">将字符串拆分为一个列表，在任何与RE匹配的地方将其拆分</td>
</tr>

<tr>
<td align="left"><code>sub()</code></td>
<td align="left">找到所有与RE匹配的子字符串，并用不同的字符串替换它们</td>
</tr>

<tr>
<td align="left"><code>subn()</code></td>
<td align="left">执行与<code>sub()</code>相同的操作，但返回新字符串和替换的数量</td>
</tr>
</tbody>
</table>

<h2 id="splitting-strings">Splitting Strings</h2>

<p>The <code>split()</code> method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the <code>split()</code> method of strings but provides much more generality in the delimiters that you can split by; string <code>split()</code> only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level <code>re.split()</code> function, too.</p>

<p>模式的<code>split()</code>方法将字符串在任何与RE匹配的地方分开，返回片段列表。它类似于字符串的<code>split()</code>方法，但是在分隔符中提供了更多的通用性，您可以根据这些分隔符进行分割；字符串的<code>split()</code>只支持空格或固定字符串的分割。如您所料，还有一个模块级的<code>re.split()</code>函数。</p>

<ul>
<li><p><code>.split(string[, maxsplit=0])</code><br />
Split <code>string</code> by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If <code>maxsplit</code> is nonzero, at most <code>maxsplit</code> splits are performed.</p></li>

<li><p><code>.split(string[, maxsplit=0])</code><br />
根据正则表达式的匹配值拆分<code>string</code>。如果捕获括号在RE中使用，那么它们的内容也将作为结果列表的一部分返回。如果<code>maxsplit</code>非零，则最多执行<code>maxsplit</code>次分割。</p></li>
</ul>

<p>You can limit the number of splits made, by passing a value for <code>maxsplit</code>. When <code>maxsplit</code> is nonzero, at most <code>maxsplit</code> splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters.</p>

<p>您可以通过为<code>maxsplit</code>传递一个值来限制分割的数量。当<code>maxsplit</code>为非零时，将最多执行<code>maxsplit</code>次分割，并将字符串（分割得到的）部分作为列表的最后一个元素返回。在下面的示例中，分隔符是任何非字母数字字符序列。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().')
['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
&gt;&gt;&gt; p.split('This is a test, short and sweet, of split().', 3)
['This', 'is', 'a', 'test, short and sweet, of split().']
</code></pre>

<p>Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls:</p>

<p>有时，您不仅对分隔符之间的文本是什么感兴趣，还需要知道分隔符是什么。如果捕获括号在RE中使用，那么它们的值也作为列表的一部分返回。比较以下调用：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile(r'\W+')
&gt;&gt;&gt; p2 = re.compile(r'(\W+)')
&gt;&gt;&gt; p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
&gt;&gt;&gt; p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
</code></pre>

<p>The module-level function <code>re.split()</code> adds the RE to be used as the first argument, but is otherwise the same.</p>

<p>模块级的函数<code>re.split()</code>添加RE作为第一个参数使用，但在其他方面是相同的。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; re.split(r'[\W]+', 'Words, words, words.')
['Words', 'words', 'words', '']
&gt;&gt;&gt; re.split(r'([\W]+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
&gt;&gt;&gt; re.split(r'[\W]+', 'Words, words, words.', 1)
['Words', 'words, words.']
</code></pre>

<h2 id="search-and-replace">Search and Replace</h2>

<p>Another common task is to find all the matches for a pattern, and replace them with a different string. The <code>sub()</code> method takes a replacement value, which can be either a string or a function, and the string to be processed.</p>

<p>另一个常见的任务是查找模式的所有匹配项，并用不同的字符串替换它们。<code>sub()</code>方法接受一个替换值(可以是字符串或函数)和要处理的字符串。</p>

<ul>
<li><p><code>.sub(replacement, string[, count=0])</code><br />
Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in <code>string</code> by the replacement <code>replacement</code>. If the pattern isn’t found, <code>string</code> is returned unchanged.<br />
The optional argument <code>count</code> is the maximum number of pattern occurrences to be replaced; <code>count</code> must be a non-negative integer. The default value of 0 means to replace all occurrences.</p></li>

<li><p><code>.sub(replacement, string[, count=0])</code><br />
通过替换<code>replacement</code>来替换<code>string</code>中最左边不重叠的RE得到的字符串。如果没有找到模式，<code>string</code>将不加修改地返回。<br />
可选参数<code>count</code>是要替换的模式出现的最大数量；<code>count</code>必须是非负整数。默认值0表示替换所有发生的事件。</p></li>
</ul>

<p>Here’s a simple example of using the <code>sub()</code> method. It replaces colour names with the word <code>colour</code>:</p>

<p>下面是一个使用<code>sub()</code>方法的简单示例。它将颜色名称替换为<code>colour</code>:</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('(blue|white|red)')
&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes')
'colour socks and colour shoes'
&gt;&gt;&gt; p.sub('colour', 'blue socks and red shoes', count=1)
'colour socks and red shoes'
</code></pre>

<p>The <code>subn()</code> method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed:</p>

<p><code>subn()</code>方法执行相同的工作，但返回一个二元组，其中包含新的字符串值和执行的替换数量：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('(blue|white|red)')
&gt;&gt;&gt; p.subn('colour', 'blue socks and red shoes')
('colour socks and colour shoes', 2)
&gt;&gt;&gt; p.subn('colour', 'no colours at all')
('no colours at all', 0)
</code></pre>

<p>Empty matches are replaced only when they’re not adjacent to a previous empty match.</p>

<p>只有当空匹配项与前一个空匹配项不相邻时，才会替换它们。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('x*')
&gt;&gt;&gt; p.sub('-', 'abxd')
'-a-b--d-'
</code></pre>

<p>If <code>replacement</code> is a string, any backslash escapes in it are processed. That is, <code>\n</code> is converted to a single newline character, <code>\r</code> is converted to a carriage return, and so forth. Unknown escapes such as <code>\&amp;</code> are left alone. Backreferences, such as <code>\6</code>, are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string.</p>

<p>如果<code>replacement</code>是一个字符串，则处理其中的任何反斜杠转义。也就是说，<code>\n</code>转换为单个换行字符，<code>\r</code>转换为回车符，等等。未知的转义如<code>\&amp;</code>则被单独保留。反向引用如<code>\6</code>，由RE中相应组匹配的子字符串替换。这使您可以将原始文本的一部分合并到结果替换字符串中。</p>

<p>This example matches the word <code>section</code> followed by a string enclosed in <code>{</code>, <code>}</code>, and changes <code>section</code> to <code>subsection</code>:</p>

<p>这个例子匹配了<code>section</code>这个单词，后面跟着一个用<code>{</code>、<code>}</code>括起来的字符串，并将<code>section</code>改为<code>subsection</code>：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('section{ ( [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First} section{second}')
'subsection{First} subsection{second}'
</code></pre>

<p>There’s also a syntax for referring to named groups as defined by the <code>(?P&lt;name&gt;...)</code> syntax. <code>\g&lt;name&gt;</code> will use the substring matched by the group named <code>name</code>, and <code>\g&lt;number&gt;</code> uses the corresponding group number. <code>\g&lt;2&gt;</code> is therefore equivalent to <code>\2</code>, but isn’t ambiguous in a replacement string such as <code>\g&lt;2&gt;0</code>. (<code>\20</code> would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character <code>'0'</code>.) The following substitutions are all equivalent, but use all three variations of the replacement string.</p>

<p>还有一个语法用于引用由<code>(?P&lt;name&gt;...)</code>语法定义的命名组。<code>\g&lt;name&gt;</code>将使用与名为<code>name</code>的组匹配的子字符串，<code>\g&lt;number&gt;</code>将使用相应的组号。因此，<code>\g&lt;2&gt;</code>等价于<code>\2</code>，但在替换字符串如<code>\g&lt;2&gt;0</code>中没有歧义（<code>\20</code>会被解释为对第20组的引用，而不是对第2组的引用，后者后跟字面的字符<code>'0'</code>。）。下面的替换都是等价的，使用替换字符串的所有三种变体。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; p = re.compile('section{ (?P&lt;name&gt; [^}]* ) }', re.VERBOSE)
&gt;&gt;&gt; p.sub(r'subsection{\1}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;1&gt;}','section{First}')
'subsection{First}'
&gt;&gt;&gt; p.sub(r'subsection{\g&lt;name&gt;}','section{First}')
'subsection{First}'
</code></pre>

<p><code>replacement</code> can also be a function, which gives you even more control. If <code>replacement</code> is a function, the function is called for every non-overlapping occurrence of <code>pattern</code>. On each call, the function is passed a <code>match object</code> argument for the match and can use this information to compute the desired replacement string and return it.</p>

<p><code>replacement</code>也可以是一个函数，它可以给你更多的控制。如果<code>replacement</code>是一个函数，则对<code>pattern</code>的每个非重叠出现调用该函数。在每次调用时，函数都会被传递一个<code>match object</code>参数，用于匹配，并且可以使用该信息来计算所需的替换字符串并返回它。</p>

<p>In the following example, the replacement function translates decimals into hexadecimal:</p>

<p>在下面的例子中，替换函数将小数转换为十六进制：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; def hexrepl(match):
...     &quot;Return the hex string for a decimal number&quot;
...     value = int(match.group())
...     return hex(value)
...
&gt;&gt;&gt; p = re.compile(r'\d+')
&gt;&gt;&gt; p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.')
'Call 0xffd2 for printing, 0xc000 for user code.'
</code></pre>

<p>When using the module-level <code>re.sub()</code> function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. <code>sub(&quot;(?i)b+&quot;, &quot;x&quot;, &quot;bbbb BBBB&quot;)</code> returns <code>'x x'</code>.</p>

<p>当使用模块级的<code>re.sub()</code>函数时，模式作为第一个参数传递。模式可以以对象或字符串提供；如果需要指定正则表达式标志，则必须使用模式对象作为第一个参数，或者在模式字符串中使用嵌入的修饰符，例如，<code>sub(&quot;(?i)b+&quot;, &quot;x&quot;, &quot;bbbb BBBB&quot;)</code>返回<code>'x x'</code>。</p>

<h1 id="common-problems">Common Problems</h1>

<p>Regular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls.</p>

<p>正则表达式对于某些应用程序来说是一个强大的工具，但在某些方面，它们的行为并不直观，有时它们的行为也不像您期望的那样。本节将指出一些最常见的陷阱。</p>

<h2 id="use-string-methods">Use String Methods</h2>

<p>Sometimes using the <code>re</code> module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any <code>re</code> features such as the <code>IGNORECASE</code> flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine.</p>

<p>有时使用<code>re</code>模块是一个错误。如果您匹配的是一个固定的字符串或一个字符类，并没有使用任何<code>re</code>特性，比如<code>IGNORECASE</code>'标志，那么可能就不需要正则表达式的全部功能。字符串有几个方法来执行固定字符串的操作，它们通常要快得多，因为实现是一个单独的小的C循环，并为此进行了优化，而不是大型的、更一般化的正则表达式引擎。</p>

<p>One example might be replacing a single fixed string with another one; for example, you might replace <code>word</code> with <code>deed</code>. <code>re.sub()</code> seems like the function to use for this, but consider the <code>replace()</code> method. Note that <code>replace()</code> will also replace <code>word</code> inside words, turning <code>swordfish</code> into <code>sdeedfish</code>, but the naive RE <code>word</code> would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be <code>\bword\b</code>, in order to require that <code>word</code> have a word boundary on either side. This takes the job beyond <code>replace()</code>’s abilities.)</p>

<p>一个例子可能是用另一个字符串替换一个固定的字符串；例如，你可以将<code>word</code>替换为<code>deed</code>。<code>re.sub()</code>似乎是用于此目的的函数，但请考虑<code>replace()</code>方法。注意，<code>replace()</code>也将替换<code>word</code>内部单词，将<code>swordfish</code>转换为<code>sdeedfish</code>，但朴素RE的<code>word</code>也会这样做。(为了避免对单词的部分进行替换，模式必须是<code>\bword\b</code>，以便要求<code>word</code>的两边都有单词边界。这使工作超出了<code>replace()</code>的能力范围。</p>

<p>Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like <code>re.sub('\n', ' ', S)</code>, but <code>translate()</code> is capable of doing both tasks and will be faster than any regular expression operation can be.</p>

<p>另一个常见的任务是从字符串中删除单个字符的任何出现，或者用另一个字符替换它。你可以用<code>re.sub('\n', ' ', S)</code>，但是<code>translate()</code>能够完成这两个任务，而且比任何正则表达式操作都要快。</p>

<p>In short, before turning to the <code>re</code> module, consider whether your problem can be solved with a faster and simpler string method.</p>

<p>简而言之，在转到<code>re</code>模块之前，请考虑是否可以使用更快更简单的字符串方法来解决您的问题。</p>

<h2 id="match-versus-search">match() versus search()</h2>

<p>The <code>match()</code> function only checks if the RE matches at the beginning of the string while <code>search()</code> will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, <code>match()</code> will only report a successful match which will start at 0; if the match wouldn’t start at zero, <code>match()</code> will not report it.</p>

<p><code>match()</code>函数只检查字符串开头的RE是否匹配，而<code>search()</code>将向前扫描整个字符串以查找匹配。记住这一点很重要。记住，<code>search()</code>将只报告一个从0开始的成功匹配；如果匹配不是从零开始，<code>search()</code>将不会报告它。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.match('super', 'superstition').span())
(0, 5)
&gt;&gt;&gt; print(re.match('super', 'insuperable'))
None
</code></pre>

<p>On the other hand, <code>search()</code> will scan forward through the string, reporting the first match it finds.</p>

<p>另一方面，<code>search()</code>将向前扫描字符串，报告它找到的第一个匹配项。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.search('super', 'superstition').span())
(0, 5)
&gt;&gt;&gt; print(re.search('super', 'insuperable').span())
(2, 7)
</code></pre>

<p>Sometimes you’ll be tempted to keep using <code>re.match()</code>, and just add <code>.*</code> to the front of your RE. Resist this temptation and use <code>re.search()</code> instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with <code>Crow</code> must match starting with a <code>'C'</code>. The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a <code>'C'</code> is found.</p>

<p>有时您可能会忍不住继续使用<code>re.match()</code>，然后添加<code>.*</code>到你的RE的前面。抵制这种诱惑，用<code>re.search()</code>来代替。正则表达式编译器对REs进行一些分析，以加快查找匹配项的过程。其中一个分析指出了匹配的第一个字符必须是什么；例如，以<code>Crow</code>开头的模式必须与以<code>'C'</code>开头的模式匹配。该分析允许引擎快速扫描字符串，寻找起始字符，只有在找到<code>'C'</code>时才尝试完全匹配。</p>

<p>Adding <code>.*</code> defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use <code>re.search()</code> instead.</p>

<p>添加<code>.*</code>破坏了这个优化，需要扫描到字符串的末尾，然后回溯查找匹配的RE。使用<code>re.search()</code>代替。</p>

<h2 id="greedy-versus-non-greedy">Greedy versus Non-Greedy</h2>

<p>When repeating a regular expression, as in <code>a*</code>, the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of <code>.*</code>.</p>

<p>当重复一个正则表达式时，如在<code>a*</code>中，结果操作是匹配尽可能多的模式。当您试图匹配一对平衡的分隔符时，如围绕HTML标记的尖括号，这一事实常常困扰您。由于<code>.*</code>的贪婪特性，匹配单个HTML标记的朴素模式无法工作。</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; s = '&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;'
&gt;&gt;&gt; len(s)
32
&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).span())
(0, 32)
&gt;&gt;&gt; print(re.match('&lt;.*&gt;', s).group())
&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;
</code></pre>

<p>The RE matches the <code>'&lt;'</code> in <code>'&lt;html&gt;'</code>, and the <code>.*</code> consumes the rest of the string. There’s still more left in the RE, though, and the <code>&gt;</code> can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the <code>&gt;</code>. The final match extends from the <code>'&lt;'</code> in <code>'&lt;html&gt;'</code> to the <code>'&gt;'</code> in <code>'&lt;/title&gt;'</code>, which isn’t what you want.</p>

<p>RE与<code>'&lt;html&gt;'</code>中的<code>'&lt;'</code>匹配，而且<code>.*</code>消耗字符串的其余部分。不过，在RE中还有更多内容，而且<code>&gt;</code>在字符串末尾无法匹配，因此正则表达式引擎必须逐字符回溯，直到找到<code>&gt;</code>的匹配。最后的匹配从<code>'&lt;html&gt;'</code>中的<code>'&lt;'</code>扩展到<code>'&lt;/title&gt;'</code>中的<code>'&gt;'</code>，这不是您想要的。</p>

<p>In this case, the solution is to use the non-greedy qualifiers <code>*?</code>, <code>+?</code>, <code>??</code>, or <code>{m,n}?</code>, which match as little text as possible. In the above example, the <code>'&gt;'</code> is tried immediately after the first <code>'&lt;'</code> matches, and when it fails, the engine advances a character at a time, retrying the <code>'&gt;'</code> at every step. This produces just the right result:</p>

<p>在这种情况下，解决方案是使用非贪婪限定符的<code>*?</code>、<code>+?</code>、<code>??</code>或<code>{m,n}?</code>，它匹配的文本越少越好。在上面的例子中，<code>'&gt;'</code>在第一个<code>'&lt;'</code>匹配后立即尝试，当它失败时，引擎一次前进一个字符，每一步都重新尝试<code>'&gt;'</code>。这产生了正确的结果：</p>

<pre><code class="language-python">&gt;&gt;&gt;
&gt;&gt;&gt; print(re.match('&lt;.*?&gt;', s).group())
&lt;html&gt;
</code></pre>

<p>(Note that parsing HTML or XML with regular expressions is painful. Quick-and-dirty patterns will handle common cases, but HTML and XML have special cases that will break the obvious regular expression; by the time you’ve written a regular expression that handles all of the possible cases, the patterns will be very complicated. Use an HTML or XML parser module for such tasks.)</p>

<p>（注意，用正则表达式解析HTML或XML是很痛苦的。快速而不规范的模式将处理常见的情况，但是HTML和XML有特殊的情况，它们将破坏明显的正则表达式；当您编写了一个处理所有可能情况的正则表达式时，模式将变得非常复杂。使用HTML或XML解析器模块来完成这些任务。）</p>

<h2 id="using-re-verbose">Using re.VERBOSE</h2>

<p>By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand.</p>

<p>到目前为止，您可能已经注意到正则表达式是一种非常紧凑的表示法，但是它们的可读性不是很好。中等复杂度的REs可能成为反斜杠、括号和元字符的冗长集合，使它们难于阅读和理解。</p>

<p>For such REs, specifying the <code>re.VERBOSE</code> flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly.</p>

<p>对于此类REs，在编译正则表达式时请指定<code>re.VERBOSE</code>标志很有用，因为它允许您更清晰地格式化正则表达式。</p>

<p>The <code>re.VERBOSE</code> flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as <code>dog | cat</code> is equivalent to the less readable <code>dog|cat</code>, but <code>[a b]</code> will still match the characters <code>'a'</code>, <code>'b'</code>, or a space. In addition, you can also put comments inside a RE; comments extend from a <code>#</code> character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly:</p>

<p><code>re.VERBOSE</code>标记有几个效果。不在字符类内的正则表达式中的空白将被忽略。这意味着<code>dog | cat</code>这样的表达式等价于可读性较差的<code>dog|cat</code>，但是<code>[a b]</code>仍然会匹配字符<code>'a'</code>、<code>'b'</code>或空格。另外，还可以把注释放在RE里面；注释从<code>#</code>字符扩展到下一个换行符。当与三引号的字符串一起使用时，这使REs的格式更简洁：</p>

<pre><code class="language-python">pat = re.compile(r&quot;&quot;&quot;
 \s*                 # Skip leading whitespace
 (?P&lt;header&gt;[^:]+)   # Header name
 \s* :               # Whitespace, and a colon
 (?P&lt;value&gt;.*?)      # The header's value -- *? used to
                     # lose the following trailing whitespace
 \s*$                # Trailing whitespace to end-of-line
&quot;&quot;&quot;, re.VERBOSE)
</code></pre>

<p>This is far more readable than:</p>

<p>这比以下更易读：</p>

<pre><code class="language-python">pat = re.compile(r&quot;\s*(?P&lt;header&gt;[^:]+)\s*:(?P&lt;value&gt;.*?)\s*$&quot;)
</code></pre>

<h1 id="feedback">Feedback</h1>

<p>Regular expressions are a complicated topic. Did this document help you understand them? Were there parts that were unclear, or Problems you encountered that weren’t covered here? If so, please send suggestions for improvements to the author.</p>

<p>正则表达式是一个复杂的主题。这份文档对你理解他们有帮助吗？是否有不清楚的地方，或者您遇到的问题没有在这里讨论？如果是，请将改进建议发送给作者。</p>

<p>The most complete book on regular expressions is almost certainly Jeffrey Friedl’s Mastering Regular Expressions, published by O’Reilly. Unfortunately, it exclusively concentrates on Perl and Java’s flavours of regular expressions, and doesn’t contain any Python material at all, so it won’t be useful as a reference for programming in Python. (The first edition covered Python’s now-removed regex module, which won’t help you much.) Consider checking it out from your library.</p>

<p>关于正则表达式最完整的书几乎可以肯定是由O'Reilly出版的Jeffrey Friedl的《精通正则表达式》。不幸的是，它只关注Perl和Java风格的正则表达式，根本不包含任何Python内容，所以作为Python编程的参考并没有什么用处。(第一版覆盖了Python现在已删除的regex模块，这对您帮助不大。)考虑从你的书目删除。</p>

    </article>
  </div>

  
  
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  
<link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
<script>
window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#216942",
      "text": "#b2d192"
    },
    "button": {
      "background": "#afed71"
    }
  }
})});
</script>

</body>

</html>